// Projet_Malware.cpp : définit le point d'entrée pour l'application console.
//

/*
SOURCES 

base 64 : stackoverflow.com/questions/342409/how-do-i-base64-encode-decode-in-c

*/

#include "stdafx.h"
#include "string.h"
#include "stdlib.h"
#include "Windows.h"
#include "stdint.h"


char* code(char* str, int len){
	char* toHardcode = (char*) calloc(len,sizeof(char));
	strcpy(toHardcode, str);

	for(int i =1; i < len; i++){
		for(int j = len -1; j >=i; j--){
			toHardcode[j] = toHardcode[j-1] ^ toHardcode[j];
		}
	}
	return toHardcode;
}

char* decode(char* coded, int len){
	char* decoded = (char*) calloc(len, sizeof(char));
	strcpy(decoded, coded);

	for(int i= len -1; i > 0; i--){
		for(int j=i; j<len; j++){
			decoded[j]= decoded[j-1] ^ decoded[j];
		}
	}
	return decoded;
}

static char encoding_table[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
                                'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
                                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                                'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
                                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
                                'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
                                'w', 'x', 'y', 'z', '0', '1', '2', '3',
                                '4', '5', '6', '7', '8', '9', '+', '/'};

static char *decoding_table = NULL;  

static int mod_table[] = {0, 2, 1};

void build_decoding_table() {

    decoding_table = (char * ) malloc(256);

    for (int i = 0; i < 64; i++)
        decoding_table[(unsigned char) encoding_table[i]] = i;
}


char *base64_encode(const unsigned char *data,
                    size_t input_length,	
                    size_t *output_length) {

    *output_length = 4 * ((input_length + 2) / 3);

    char *encoded_data = (char * ) malloc(*output_length);
    if (encoded_data == NULL) return NULL;

    for (int i = 0, j = 0; i < input_length;) {

        uint32_t octet_a = i < input_length ? (unsigned char)data[i++] : 0;
        uint32_t octet_b = i < input_length ? (unsigned char)data[i++] : 0;
        uint32_t octet_c = i < input_length ? (unsigned char)data[i++] : 0;

        uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;

        encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
        encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
        encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
        encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
    }

    for (int i = 0; i < mod_table[input_length % 3]; i++)
        encoded_data[*output_length - 1 - i] = '=';

    return encoded_data;
}

unsigned char *base64_decode(const char *data,
                             size_t input_length,
                             size_t *output_length) {

    if (decoding_table == NULL) build_decoding_table();

    if (input_length % 4 != 0) return NULL;

    *output_length = input_length / 4 * 3;
    if (data[input_length - 1] == '=') (*output_length)--;
    if (data[input_length - 2] == '=') (*output_length)--;

    unsigned char *decoded_data = (unsigned char * )malloc(*output_length);
    if (decoded_data == NULL) return NULL;

    for (int i = 0, j = 0; i < input_length;) {

        uint32_t sextet_a = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
        uint32_t sextet_b = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
        uint32_t sextet_c = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];
        uint32_t sextet_d = data[i] == '=' ? 0 & i++ : decoding_table[data[i++]];

        uint32_t triple = (sextet_a << 3 * 6)
        + (sextet_b << 2 * 6)
        + (sextet_c << 1 * 6)
        + (sextet_d << 0 * 6);

        if (j < *output_length) decoded_data[j++] = (triple >> 2 * 8) & 0xFF;
        if (j < *output_length) decoded_data[j++] = (triple >> 1 * 8) & 0xFF;
        if (j < *output_length) decoded_data[j++] = (triple >> 0 * 8) & 0xFF;
    }

    return decoded_data;
}



void base64_cleanup() {
    free(decoding_table);
}

int cmpChiff(char* a, char* b, int len1, int len2){ // len1 = len de argv // len2 = cle cachée
	if(len1 < len2 || len2 < len1){
		return 0;
	}else{
	for(int i = 0; i < len2; i++){
		if(a[i] < b[i] || a[i] > b[i]){
			return 0;
		}
	}
	return 1;
	}
} 

char dt[] = {'\xff', '\xff', '\xff', '\x6f', '\xe8'};

int compare(int blabla){ //mettre plien de fausses fonctions
	return 0;
}


int main(int argc, char* argv[])
{
	/*
	const unsigned char* gg = (const unsigned char *)"GG Champion!";

	size_t * point = (size_t *) malloc(sizeof(size_t));

	char* res = base64_encode(gg, 13, point);

	printf("Version codee : %s\n", res);

	for(int i = 0; i<strlen(res); i++){
		printf("ici = %d\n", (int) res[i]);
	}
	*/
	/*int rrss[] = {82,48,99,103,81,50,104,104,98,88,66,112,98,50,52,104,65,65,61,61,32,70,105,108,5};
		

	char rrsstt[256] = "";
		for(int i = 0; i<25; i++){
			rrsstt[i] = (char)rrss[i];
		}*/
	//printf("Code restitue = %s\n", rrsstt);

	//size_t * point2 = (size_t *) malloc(sizeof(size_t));

	//printf("Version decodee = %s\n", base64_decode((const char *)rrsstt, 24, point2));
	/*
	char* coded1 = code(argv[1], strlen(argv[1]));

	int testing1[] = {48,72,1,75,118,75,114,75,9,48,126,48,10,51,9,66,4,78,3,62,116,62,5,63,8,66,112,49,5,60,123,73,5,75,6,59,116,77,116,48,13,52,124,71,10,52,15,57,8,70,10,65,121,48,12,71,115,74,121,56,122,53,117,70,5,75,3,71,113,67,3,78,121,51,120,79,125,56,126,57,1,73,9,57,118,70,12,70,11,63,10,61,118,61,112,70,3,57,3,48,1,54,6,48,13,55,11,77,127,55,7,50,120,55,117,65,122,63,115,61,112,51,115,68,15,57,3,75,7,71,6,68,113,69,117,76,9,58,12,58,127,62,127,70,118,69,4,49,115,64,114,76,117,77,10,56,112,64,122,56,7,64,7,54,112,73,122,54,8,51,9,69,123,59,114,55,120,70,5,74};
		
	//0x12FE569AFEEEA3426E6EC15A998614562A72681644356792736578FAC56743567829ACEEA2567904875AEFC975BB2B3B4BACEEC2563994FA43562765ECACE67800010972BBECAAEAEAE1558902887551356894091276447890
	printf("Debut programme \nClee cachee = ");
	char reco1[256] = "";
	
	for(int i = 0; i<180; i++){
		reco1[i] = (char)testing1[i];
	}*/
	//printf("%s\n", reco1);
	//printf("strlen cleEntree = %d\n", strlen(reco1));
	//printf("strlen coded = %d\n", strlen(coded1));
	//printf("%d", strcmp(coded1, reco1));

	//printf("%s\n", reco1);
	//printf("Coded : %s\n", coded1);
	//printf("strlen coded1 = %d\n", strlen(coded1));
	//printf("strlen argv = %d\n", strlen(argv[1]));
	//printf("cmp = %d\n", cmpChiff(argv[1], reco1, strlen(argv[1]), strlen(reco1)));
	//char* decoded1 = decode(coded1, strlen(coded1));
	//printf("coded = %s\n\n", coded1);
	//printf("decoded = %s\n", decoded1);
	//while(1);

	if(argc > 1){
		int testing[] = {48,72,1,75,118,75,114,75,9,48,126,48,10,51,9,66,4,78,3,62,116,62,5,63,8,66,112,49,5,60,123,73,5,75,6,59,116,77,116,48,13,52,124,71,10,52,15,57,8,70,10,65,121,48,12,71,115,74,121,56,122,53,117,70,5,75,3,71,113,67,3,78,121,51,120,79,125,56,126,57,1,73,9,57,118,70,12,70,11,63,10,61,118,61,112,70,3,57,3,48,1,54,6,48,13,55,11,77,127,55,7,50,120,55,117,65,122,63,115,61,112,51,115,68,15,57,3,75,7,71,6,68,113,69,117,76,9,58,12,58,127,62,127,70,118,69,4,49,115,64,114,76,117,77,10,56,112,64,122,56,7,64,7,54,112,73,122,54,8,51,9,69,123,59,114,55,120,70,5,74};

		int testingSize = 180;
		
		int rrss[] = {82,48,99,103,81,50,104,104,98,88,66,112,98,50,52,104,65,65,61,61,32,70,105,108,5};
		char rrsstt[256] = "";
		
		for(int i = 0; i<25; i++){
			rrsstt[i] = (char)rrss[i];
		}
		char* coded = code(argv[1], strlen(argv[1]));
		//printf("coded Argv[1] = %s\n", coded);
		//printf("Clee cachee = ");
		char reco[256] = "";
		for(int i = 0; i<180; i++){
			reco[i] = (char)testing[i];
			//printf("%c", (char)testing[i]);
		}
		//printf("%s\n", reco);

		//DWORD old;
		//VirtualProtect(s, 6, PAGE_EXECUTE_READWRITE, &old);


		if(cmpChiff(reco,coded, strlen(argv[1]), testingSize)==1){
			size_t * point2 = (size_t *) malloc(sizeof(size_t));
			printf("%s\n", base64_decode((const char *)rrsstt, 24, point2));
		}else{
			printf("%s\n", argv[1]);
		}
		char* decoded = decode(coded, strlen(coded));
		//printf("Decoded = %s\n", decoded);

	}else{
		printf("At least try to play ...\n");
		return 1;
	}
	return 0;
}



