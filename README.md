--------------------------------------------------

# Projet Malware
Groupe :

ENESCU Michael
BEAUDOUIN Nicolas

--------------------------------------------------



# Objectif du document:




Ce programme a été créé afin de s'entraîner à l'offuscation de programme.


Ce document a pour objectif d'expliquer son fonction.




-------------------------------------------------

# Résumé du fonctionnement: 

Voici toutes les fonctionnalités que nous avons implémentés dans le code:



- Empaquetage de l'éxécutable avec UPX
- AntiDebug avec IsDebuggerPresent() placés à plusieurs endroits
- Codage des strings indiquant si l'utilisateur à gagné ou perdu. Ce codage se fait de deux manière différente: d'abord avec les caractères ASCII dans un tableau (au lieu de strings) et ensuite nous avons codés par exemple "GG champion" avec un chiffrement en base64 en plus, donc nous avons utilisé une fonction de déchiffrement en base64.
- Fonction de codage: Nous avons codé notre clé à l'aide d'une fonction réversible complexe avec des xor puis nous avons utilisé des opérations à priori irréversible afin de rendre l'opération pour retrouver la clé quasi impossible sans brute-force.
- Fausses pistes avec des strings codés en dur: "Bien joué" ... ou encore quelques fonctions inutiles.
- Nous avons obfusqué le code C++ au cas où le compilateur garde certains nom de fonctions.



# Fonctionnemment:




L'utilisateur lance le programme en donnant en entrée un nombre en hexadécimal.


Ce nombre doit être donné au format 0xA1234BCDEF, soit les lettres représentant un nombre en hexa doivent être écrites en majuscules.

Toutes les 2,3 lignes, un "IsDebuggerPresent()" est réalisé.

Dans le code sont stockées différentes chaînes de caractères sous différents formats.



Certaines chaînes de caractère non-importantes sont écrites en dur comme "At least try to play ...\n".



Les autres chaînes sont stockées sous forme de liste d'entiers au format ASCII:



Ainsi, "AH!" sera stocké sous la forme : {65, 72, 33}.



Ce mode de stockage est utilisé pour toutes les chaînes de caractères plus importantes comme "GG Champion!" et le stockage de la clé.



Pour ces chaînes importantes, elles sont stockées après avoir reçu un certain traitement.

Un piège a été mis dans le code: un texte est écrit en dur comme étant "Bien joué". Ce texte est encapusé dans un "if(a=b)" avec a !=b encaspulé dans un "if(IsDebuggerPresent)" avec plusieures autres modifications innutiles. Ce code n'a rien avoir avec l'execution normale du programme et n'est en théorie pas appellé au cours de l'exécution. 




--------------------------------------------------



## Opérations de chiffrement



Afin de chiffrer les clés et la chaîne de caractère "GG Champion!", nous avons d'une part créée des fonctions de chiffrement


et d'autre part utilisé une fonction existante de chiffrement en base 64 (https://stackoverflow.com/questions/342409/how-do-i-base64-encode-decode-in-c).


Le chiffrement en base 64 a été uniquement utilisé pour la chaîne de caractère "GG Champion", la clé a été chiffrée avec une fonction que nous avons créé.





### Chiffrement de la clé :



Ce chiffrement se réalise en 3 étapes :


- un certain enchaînement de "xor"s avec lui-même


- un mélange des "char"s de la clé


- une inversion de la valeur ASCII de certains caractères



-- Enchaînements de "xor"s




La chaîne reçue en entrée est passé en entrée de la fonction suivante :




""""



char* toHardcode = (char*) calloc(len,sizeof(char));


strcpy(toHardcode, str);



for(int i =1; i < len; i++){


for(int j = len -1; j >=i; j--){


toHardcode[j] = toHardcode[j-1] ^ toHardcode[j];


}


}



""""



Pour chaque élément de la chaîne de caractères, nous "xor"ons cet élément avec son prédécesseur en commençant avec la fin


de la chaîne et diminuant petit à petit l'élément de départ du "xor".

Par exemple si on a une chaine de caractère char[]  = {A B C}

La première étape consiste à faire char[2] = B xor C = C' 
                                puis char[1] = A xor B = B'
Ensuite, la seconde étape (on a n-1 étape avec n la longeur de la chaine):
                                char[2] = B' xor C' = C"

On obtient donc la chaine {A B' C"}



-- Mélange des "char"s de la clé



Nous parcourrons pour chaque élément de la chaîne de caractère :


- si son code ASCII est < 150 et que son indice est inférieur à 150, nous échangeons cet élément avec celui à la position son code ASCII.


- sinon rien



-Inversion de la valeur ASCII



Une fois que les deux opérations précédentes ont été réalisées dans cet ordre, nous convertissons la chaîne de caractère en un tableau de int


selon la méthode expliquée précédemment, soit à un caractère, nous attribuons son code ASCII.


Nous inversons ensuite les codes ASCII inférieurs à 100 de la manière suivante : "14" devient"41" puis pour chaque code ASCII, nous effectuons l'opération suivante : 1234* (code ASCII) %139.



-------------------------------------------------



## Vérification :



Nous avons codé une fonction spéciale de vérification de la clé. Son action est cependant très similaire à strcmp().



Nous avions au préalable codé la valeur de la clé après toutes les opérations précédentes.



Elle était donc stockée sous la forme d'un array de int. Nous convertissons cet array en un char* et comparons avec la fonction que nous avions créé le résultat.



Au final, si le résultat est correct, nous décodons la chaîne de caractère "GG Champion!" précédement codée en base 64 et l'affichons dans le terminal.

Sinon, nous renvoyons "argv[1]".


------

## Empaquetage du binaire

Le binaire a été empaqueté avec UPX ensuite.

-----

Voici la clé en clair "0x12FE569AFEEEA3426E6EC15A998614562A72681644356792736578FAC56743567829ACEEA2567904875AEFC975BB2B3B4BACEEC2563994FA43562765ECACE67800010972BBECAAEAEAE1558902887551356894091276447890"


